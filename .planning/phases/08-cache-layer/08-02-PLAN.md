---
phase: 08-cache-layer
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - tasks/orchestrator.js
  - tasks/echo/config.js
  - tasks/index.js
autonomous: true

must_haves:
  truths:
    - "Orchestrator checks cache before executing helpers when task config has cache settings"
    - "Orchestrator stores result in cache after successful execution when task config has cache settings"
    - "Cached responses have meta.cached set to true"
    - "Tasks without cache config skip caching entirely"
    - "Repeated echo requests within TTL return cached LLMPayload instantly"
  artifacts:
    - path: "tasks/orchestrator.js"
      provides: "Cache-aware task runner with check-before-execute and store-after-execute"
      exports: ["createRunner"]
    - path: "tasks/echo/config.js"
      provides: "Echo task config with cache settings demonstrating the pattern"
      contains: "cache"
    - path: "tasks/index.js"
      provides: "Entry point that runs clearExpired on startup"
      contains: "clearExpired"
  key_links:
    - from: "tasks/orchestrator.js"
      to: "tasks/cache.js"
      via: "require('./cache')"
      pattern: "require.*cache"
    - from: "tasks/echo/config.js"
      to: "tasks/orchestrator.js"
      via: "cache config consumed by orchestrator"
      pattern: "cache:"
---

<objective>
Integrate cache into the orchestrator pipeline and add cache config to echo task as proof of pattern.

Purpose: Complete the cache layer by wiring cache.js into the orchestrator's execution pipeline. After this, any task can opt into caching by adding a cache section to its config.js -- no orchestrator changes needed (same extensibility pattern as Phase 7).

Output: Updated orchestrator.js with cache-aware pipeline, updated echo/config.js with cache settings, updated index.js with clearExpired on load.
</objective>

<execution_context>
@/Users/greg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/greg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-cache-layer/08-01-SUMMARY.md
@tasks/orchestrator.js
@tasks/echo/config.js
@tasks/index.js
@tasks/cache.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cache check/store to orchestrator pipeline</name>
  <files>tasks/orchestrator.js</files>
  <action>
Update tasks/orchestrator.js to integrate caching into the runner pipeline.

**TaskConfig cache shape** (optional, tasks without it skip caching):
```
cache: {
  ttl: 300000,              // TTL in ms (5 min), optional
  dailyReset: false,        // timezone-aware daily expiry, optional
  keyStrategy: (task, intent, params) => string  // optional custom key builder
}
```

**Updated pipeline in createRunner():**

1. Validate intent (existing)
2. Validate parameters (existing)
3. **NEW - Cache check**: If taskConfig.cache exists:
   - Build key via `cache.buildKey(task, intent, parameters, taskConfig.cache.keyStrategy)`
   - Call `cache.get(key)`
   - If cache hit: return the cached LLMPayload but set `meta.cached = true` and update `meta.timestamp` to now
   - If cache miss: continue to step 4
4. Execute helpers sequentially (existing)
5. Wrap in LLMPayload (existing)
6. **NEW - Cache store**: If taskConfig.cache exists and result is not an error:
   - Call `cache.set(key, payload, { ttl: taskConfig.cache.ttl, dailyReset: taskConfig.cache.dailyReset })`
7. Return payload

**Important:** Only cache successful responses (where meta.error is null). Error payloads should NOT be cached.

Add `const cache = require('./cache');` at the top.
  </action>
  <verify>
1. `const { createRunner } = require('./tasks/orchestrator')` loads without error
2. Create a mock task config with cache enabled and verify the runner checks cache before executing
3. Verify that a second call with same parameters returns cached result with meta.cached = true
  </verify>
  <done>
Orchestrator pipeline checks cache before helper execution and stores results after. Tasks opt in via cache config in their TaskConfig. Tasks without cache config work exactly as before.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cache config to echo task and clearExpired to index.js</name>
  <files>tasks/echo/config.js, tasks/index.js</files>
  <action>
**Update tasks/echo/config.js:**
Add a cache section to the echo TaskConfig to demonstrate the pattern:
```js
cache: {
  ttl: 60000  // 1 minute TTL for echo (short, since it's a demo task)
}
```
This proves CACHE-02: each task defines its own cache settings in config.

**Update tasks/index.js:**
Add a call to `cache.clearExpired()` at module load time (after requiring cache):
```js
const cache = require('./cache');
// Clean stale entries on startup
cache.clearExpired();
```
This ensures expired entries are purged each time the task system initializes. Since the agent runs tasks via `node tasks/index.js "..."`, this happens naturally on each CLI invocation.

No other changes to index.js -- the runTask() function does not need modification since the orchestrator handles caching internally.
  </action>
  <verify>
1. Run `node tasks/index.js "echo get hello"` -- returns LLMPayload with meta.cached = false
2. Run `node tasks/index.js "echo get hello"` again immediately -- returns LLMPayload with meta.cached = true
3. Check /memory/cache.json exists and contains the echo entry
4. Wait 60+ seconds (or manually edit cache entry's storedAt to be old), run again -- returns meta.cached = false (TTL expired, re-executed)
5. Run `node tasks/index.js "echo get different"` -- returns meta.cached = false (different key)
6. Run `node tasks/index.js "nonexistent get"` -- still returns error payload (unchanged behavior)
  </verify>
  <done>
Echo task config demonstrates cache pattern with 1-minute TTL. index.js clears expired entries on startup. Full pipeline proven: raw input -> normalize -> cache check -> execute (or cache hit) -> cache store -> LLMPayload response. Adding caching to a new task requires only adding a `cache` section to its config.js.
  </done>
</task>

</tasks>

<verification>
- Orchestrator checks cache before executing helpers
- Orchestrator stores result after successful execution
- Cached responses have meta.cached = true
- Error responses are not cached
- Echo task has cache config with TTL
- index.js clears expired entries on load
- Full pipeline works end-to-end via CLI
- Tasks without cache config work unchanged
</verification>

<success_criteria>
Cache is fully integrated into the orchestrator pipeline. Any task can opt into caching by adding a cache section to its config.js. Echo task proves the pattern with a 1-minute TTL. Repeated requests within TTL return cached responses instantly with meta.cached = true.
</success_criteria>

<output>
After completion, create `.planning/phases/08-cache-layer/08-02-SUMMARY.md`
</output>
