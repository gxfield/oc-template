---
phase: 08-cache-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tasks/cache.js
autonomous: true

must_haves:
  truths:
    - "Cache get returns null for missing or expired entries"
    - "Cache set stores LLMPayload entries with TTL metadata"
    - "Cache clearExpired removes entries past TTL or past daily reset boundary"
    - "Cache persists to /memory/cache.json as JSON file"
    - "Daily reset uses Pacific timezone to determine day boundary"
  artifacts:
    - path: "tasks/cache.js"
      provides: "Cache module with get, set, clearExpired, and buildKey operations"
      exports: ["get", "set", "clearExpired", "buildKey"]
  key_links:
    - from: "tasks/cache.js"
      to: "/memory/cache.json"
      via: "fs.readFileSync/writeFileSync"
      pattern: "readFileSync.*cache\\.json"
---

<objective>
Create the cache module (tasks/cache.js) that provides get/set/clearExpired operations backed by /memory/cache.json.

Purpose: Enable task results to be cached with TTL or daily reset expiry, reducing redundant API calls and improving agent response time. This is the foundation that the orchestrator will wire into in Plan 2.

Output: tasks/cache.js with exported get, set, clearExpired, and buildKey functions.
</objective>

<execution_context>
@/Users/greg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/greg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-task-infrastructure/07-01-SUMMARY.md
@.planning/phases/07-task-infrastructure/07-02-SUMMARY.md
@tasks/types.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cache module with get/set/clearExpired and file persistence</name>
  <files>tasks/cache.js</files>
  <action>
Create tasks/cache.js as a CommonJS module exporting four functions:

**buildKey(task, intent, parameters, keyStrategy)**
- If keyStrategy is a function: call keyStrategy(task, intent, parameters) and return the result string
- If keyStrategy is undefined/null: return default key as `${task}:${intent}` (ignores parameters for simple default)
- Key strategy enables CACHE-02: each task config defines its own keying

**get(key)**
- Read /memory/cache.json (create empty {} if file or /memory/ dir doesn't exist)
- Look up entry by key
- If entry missing: return null
- If entry has `ttl` set: check if `Date.now() - entry.storedAt > ttl` (milliseconds). If expired, return null
- If entry has `dailyReset: true`: check if entry.storedDate (YYYY-MM-DD in Pacific) !== today's date in Pacific. If different day, return null
- If valid: return entry.payload (the stored LLMPayload)

**set(key, payload, options)**
- options: { ttl?: number (ms), dailyReset?: boolean }
- Read existing cache file (or empty {})
- Store entry: { payload, storedAt: Date.now(), storedDate: todayPacific(), ttl: options.ttl || null, dailyReset: options.dailyReset || false }
- Write back to /memory/cache.json (create /memory/ dir if needed via fs.mkdirSync with recursive: true)

**clearExpired()**
- Read cache file
- Iterate all entries, remove any that would fail the get() freshness check
- Write cleaned cache back to file
- Return count of entries removed

**Implementation notes:**
- Use `Intl.DateTimeFormat('en-US', { timeZone: 'America/Los_Angeles' })` for Pacific date, then parse to YYYY-MM-DD. This matches the project's existing Pacific timezone pattern.
- Use synchronous fs operations (readFileSync/writeFileSync) for simplicity -- cache file is small.
- Wrap file reads in try/catch: if file doesn't exist, start with empty object.
- Do NOT use any external dependencies. Only `fs` and `path` from Node builtins.
- Cache file path: use path.join with __dirname parent to reach project root, then /memory/cache.json. Or simpler: use path.resolve(__dirname, '../memory/cache.json').
  </action>
  <verify>
Run in Node REPL or via node -e:
1. `const cache = require('./tasks/cache')` loads without error
2. `cache.set('test:get', {task:'test', data:'hello'}, {ttl: 60000})` creates /memory/cache.json
3. `cache.get('test:get')` returns the stored payload
4. `cache.get('nonexistent')` returns null
5. `cache.set('expire:get', {task:'test'}, {ttl: 1})` then wait 2ms then `cache.get('expire:get')` returns null
6. `cache.buildKey('echo', 'get', {query:'hi'})` returns 'echo:get'
7. `cache.buildKey('weather', 'get', {}, (t,i,p) => 'weather:daily')` returns 'weather:daily'
8. `cache.clearExpired()` runs without error and returns a number
  </verify>
  <done>
tasks/cache.js exports get, set, clearExpired, and buildKey. Cache persists to /memory/cache.json. TTL expiry works. Daily reset expiry uses Pacific timezone. Custom key strategies are supported via buildKey function parameter. All four CACHE requirements have foundation code.
  </done>
</task>

</tasks>

<verification>
- tasks/cache.js exists and loads without error
- /memory/cache.json is created on first set() call
- get() returns null for missing keys
- get() returns null for TTL-expired entries
- set() stores payload with metadata
- clearExpired() removes stale entries
- buildKey() supports custom key strategy functions
</verification>

<success_criteria>
Cache module provides all four operations (get, set, clearExpired, buildKey) with TTL and daily reset expiry support, backed by JSON file persistence at /memory/cache.json.
</success_criteria>

<output>
After completion, create `.planning/phases/08-cache-layer/08-01-SUMMARY.md`
</output>
