---
phase: 07-task-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - tasks/orchestrator.js
  - tasks/echo/config.js
  - tasks/echo/helpers/echo.js
  - tasks/index.js
autonomous: true

must_haves:
  truths:
    - "Orchestrator creates a task runner from any TaskConfig without code changes to orchestrator.js"
    - "Adding the echo task required only helpers/echo.js, config.js, and an index.js registry entry"
    - "Task runner returns a consistent LLMPayload object with task, intent, parameters, data, and meta fields"
    - "Agent can call index.js with a raw request and receive a structured LLMPayload response"
  artifacts:
    - path: "tasks/orchestrator.js"
      provides: "Config-driven task runner factory"
      exports: ["createRunner"]
    - path: "tasks/echo/config.js"
      provides: "Echo task configuration proving the pattern"
      exports: ["default object with task, intents, helpers"]
    - path: "tasks/echo/helpers/echo.js"
      provides: "Echo task helper function"
      exports: ["echo"]
    - path: "tasks/index.js"
      provides: "Task registry and main entry point"
      exports: ["runTask"]
  key_links:
    - from: "tasks/orchestrator.js"
      to: "tasks/types.js"
      via: "imports createLLMPayload and createErrorPayload for response building"
      pattern: "require.*types"
    - from: "tasks/index.js"
      to: "tasks/orchestrator.js"
      via: "imports createRunner to build runners from registered configs"
      pattern: "require.*orchestrator"
    - from: "tasks/index.js"
      to: "tasks/echo/config.js"
      via: "registers echo task config in task registry"
      pattern: "require.*echo/config"
    - from: "tasks/index.js"
      to: "tasks/read-msg.js"
      via: "imports normalizeRequest to parse raw input before routing"
      pattern: "require.*read-msg"
---

<objective>
Create the task orchestrator, echo proof task, and registry entry point.

Purpose: Complete the task infrastructure by building the config-driven orchestrator (INFRA-02), proving the add-a-task pattern (INFRA-03), and ensuring consistent LLMPayload output (INFRA-04). After this plan, the full pipeline works: raw request -> normalize -> route -> execute -> LLMPayload.

Output: `tasks/orchestrator.js`, `tasks/echo/config.js`, `tasks/echo/helpers/echo.js`, `tasks/index.js`
</objective>

<execution_context>
@/Users/greg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/greg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/codebase/CONVENTIONS.md
@.planning/phases/07-task-infrastructure/07-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create orchestrator.js task runner factory</name>
  <files>tasks/orchestrator.js</files>
  <action>
Create `tasks/orchestrator.js`.

This is the core of the task architecture (INFRA-02). It takes a TaskConfig object and returns a runner function. The runner function executes the pipeline: validate intent -> find helper -> execute helper -> wrap in LLMPayload.

**TaskConfig shape** (what each task module exports from config.js):
```js
{
  task: 'echo',                    // task name (string)
  intents: {                       // map of intent name -> intent config
    'get': {
      helpers: ['echo'],           // ordered list of helper function names to call
      validate: (params) => null,  // optional param validator, returns error string or null
    }
  },
  helpers: {                       // map of helper name -> helper function
    'echo': require('./helpers/echo').echo
  }
}
```

Export one function: `createRunner(taskConfig)`

`createRunner` returns an async function: `async (normalizedRequest) => LLMPayload`

**Runner pipeline:**
1. Look up intent in `taskConfig.intents[request.intent]`. If not found, return createErrorPayload with "Unknown intent: {intent} for task: {task}".
2. If intent has `validate` function, call it with `request.parameters`. If it returns a string (error), return createErrorPayload.
3. Execute helpers sequentially. Each helper is called as `await helper(request.parameters, context)` where context is `{ task: taskConfig.task, intent: request.intent, previousResult: null }`. The first helper's result becomes `previousResult` for the next helper.
4. The final helper's return value becomes `data` in the LLMPayload.
5. Wrap in `createLLMPayload(task, intent, parameters, data)` and return.
6. If any helper throws, catch and return `createErrorPayload(task, intent, parameters, error.message)`.

Import createLLMPayload and createErrorPayload from ./types.

Follow project conventions: CommonJS, 2-space indent, JSDoc on createRunner. No classes — just a function that returns a function.
  </action>
  <verify>
Run `node -e "const o = require('./tasks/orchestrator'); console.log(typeof o.createRunner)"` — should print "function".
  </verify>
  <done>orchestrator.js exports createRunner which takes a TaskConfig and returns an async runner function implementing the validate -> execute -> wrap pipeline.</done>
</task>

<task type="auto">
  <name>Task 2: Create echo task as pattern proof</name>
  <files>tasks/echo/config.js, tasks/echo/helpers/echo.js</files>
  <action>
Create the echo task to prove INFRA-03 (adding a new task requires only helpers/, config.js, and index.js entry).

**tasks/echo/helpers/echo.js:**
Export one function: `echo(parameters, context)`
Simply returns `{ message: parameters.query || 'echo', echoed: true }`.
This is the simplest possible helper to prove the pattern works.

**tasks/echo/config.js:**
Export a TaskConfig object:
```js
{
  task: 'echo',
  intents: {
    'get': {
      helpers: ['echo']
    }
  },
  helpers: {
    'echo': require('./helpers/echo').echo
  }
}
```

No validation needed for echo (it accepts anything). This is intentionally minimal — the point is proving the pattern, not building a useful task.

Follow project conventions: CommonJS, 2-space indent.
  </action>
  <verify>
Run `node -e "const c = require('./tasks/echo/config'); console.log(c.task, Object.keys(c.intents))"` — should print "echo ['get']".

Run `node -e "const e = require('./tasks/echo/helpers/echo'); console.log(JSON.stringify(e.echo({query: 'hello'}, {})))"` — should print `{"message":"hello","echoed":true}`.
  </verify>
  <done>Echo task exists with config.js and helpers/echo.js. Config exports valid TaskConfig shape. Helper returns structured data.</done>
</task>

<task type="auto">
  <name>Task 3: Create index.js registry and entry point</name>
  <files>tasks/index.js</files>
  <action>
Create `tasks/index.js` as the main entry point for the task system.

This is the glue that ties everything together. It maintains a task registry and provides a single function for agents to call.

**Task registry:** A plain object mapping task names to their TaskConfig:
```js
const registry = {
  echo: require('./echo/config'),
};
```

When a new task is added (calendar, weather), it gets one line here. That is INFRA-03.

**Export one function:** `async runTask(input)`

**Pipeline:**
1. Call `normalizeRequest(input)` from read-msg.js to get a NormalizedTaskRequest.
2. Look up `request.task` in registry. If not found, return createErrorPayload with "Unknown task: {task}". Available tasks: {list registered task names}.
3. Call `createRunner(taskConfig)` from orchestrator.js to get the runner.
4. Call `await runner(request)` and return the LLMPayload.
5. If normalizeRequest throws (bad input), catch and return createErrorPayload with task='unknown', intent='unknown', and the error message.

Import from: ./read-msg (normalizeRequest), ./orchestrator (createRunner), ./types (createErrorPayload).

Also add a CLI mode at the bottom so agents can invoke via shell:
```js
// CLI mode: node tasks/index.js "echo get hello"
if (require.main === module) {
  const input = process.argv.slice(2).join(' ');
  runTask(input).then(payload => {
    console.log(JSON.stringify(payload, null, 2));
  });
}
```

Follow project conventions: CommonJS, 2-space indent, JSDoc.
  </action>
  <verify>
Run `node tasks/index.js "echo get hello"` from workspace root — should print a JSON LLMPayload with task=echo, intent=get, data.message=hello, data.echoed=true, meta.error=null.

Run `node tasks/index.js "unknown get test"` — should print an error LLMPayload with meta.error containing "Unknown task".

Run `node tasks/index.js ""` — should print an error LLMPayload (bad input).

Run `node -e "const t = require('./tasks'); t.runTask({task: 'echo', intent: 'get', parameters: {query: 'world'}}).then(r => console.log(JSON.stringify(r, null, 2)))"` — should print LLMPayload with data.message=world.
  </verify>
  <done>index.js registers echo task, exports runTask, and supports both require() and CLI invocation. Full pipeline works: raw input -> normalize -> route -> execute -> LLMPayload. Adding a new task requires only a config.js, helpers/, and one registry line.</done>
</task>

</tasks>

<verification>
1. Full pipeline test: `node tasks/index.js "echo get hello"` returns valid LLMPayload JSON
2. Object input: `runTask({task: 'echo', intent: 'get', parameters: {query: 'test'}})` returns LLMPayload
3. Unknown task: `node tasks/index.js "bogus get test"` returns error LLMPayload (not crash)
4. Unknown intent: echo task with intent "delete" returns error LLMPayload
5. Echo task directory structure: tasks/echo/config.js + tasks/echo/helpers/echo.js
6. No changes needed to orchestrator.js for echo task to work
7. LLMPayload has all 5 top-level fields: task, intent, parameters, data, meta
</verification>

<success_criteria>
- orchestrator.js creates runners from TaskConfig without knowing task details (INFRA-02)
- Echo task proves the add-a-task pattern: only config.js, helpers/, index.js entry (INFRA-03)
- All responses are LLMPayload objects with consistent structure (INFRA-04)
- CLI mode allows agents to invoke via `node tasks/index.js "task intent params"`
- require() mode allows direct import for future in-process usage
- Error cases return error payloads, not crashes
</success_criteria>

<output>
After completion, create `.planning/phases/07-task-infrastructure/07-02-SUMMARY.md`
</output>
