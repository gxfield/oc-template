---
phase: 07-task-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tasks/read-msg.js
  - tasks/types.js
autonomous: true

must_haves:
  truths:
    - "Raw request string or object is normalized into a NormalizedTaskRequest with task, intent, and parameters fields"
    - "Missing or invalid fields produce a clear validation error instead of silent failure"
    - "LLMPayload shape is defined once and reusable by all task runners"
  artifacts:
    - path: "tasks/read-msg.js"
      provides: "Request normalization and validation"
      exports: ["normalizeRequest"]
    - path: "tasks/types.js"
      provides: "Shape constructors for NormalizedTaskRequest and LLMPayload"
      exports: ["createTaskRequest", "createLLMPayload", "createErrorPayload"]
  key_links:
    - from: "tasks/read-msg.js"
      to: "tasks/types.js"
      via: "imports createTaskRequest for building normalized objects"
      pattern: "require.*types"
---

<objective>
Create the request normalization layer and shared type constructors for the task architecture.

Purpose: Establish the input (NormalizedTaskRequest) and output (LLMPayload) contracts that the orchestrator and all task runners will use. This is the foundation that INFRA-01 and INFRA-04 depend on.

Output: `tasks/read-msg.js` (normalizer) and `tasks/types.js` (shape constructors)
</objective>

<execution_context>
@/Users/greg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/greg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/codebase/CONVENTIONS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types.js with NormalizedTaskRequest and LLMPayload constructors</name>
  <files>tasks/types.js</files>
  <action>
Create `tasks/types.js` at workspace root (not inside calendar/).

This file defines the two core shapes used everywhere in the task architecture:

**NormalizedTaskRequest** — what goes IN to task runners:
```js
{
  task: 'calendar',      // which task module (string, required)
  intent: 'get',         // what to do (string, required)
  parameters: {},        // intent-specific params (object, default {})
  raw: ''                // original input for debugging (string, default '')
}
```

**LLMPayload** — what comes OUT of task runners:
```js
{
  task: 'calendar',      // which task produced this (string)
  intent: 'get',         // what was done (string)
  parameters: {},        // what was requested (object)
  data: {},              // the actual result (object or array)
  meta: {                // metadata
    timestamp: '...',    // ISO string, Pacific time context
    cached: false,       // was this from cache?
    error: null          // error message if failed (string or null)
  }
}
```

Export three factory functions:
- `createTaskRequest(task, intent, parameters = {}, raw = '')` — returns a NormalizedTaskRequest. Throws if task or intent missing.
- `createLLMPayload(task, intent, parameters, data, meta = {})` — returns an LLMPayload with defaults merged into meta (timestamp = new Date().toISOString(), cached = false, error = null).
- `createErrorPayload(task, intent, parameters, errorMessage)` — shorthand for createLLMPayload with data: null and meta.error set.

Follow project conventions: CommonJS require/module.exports, 2-space indent, JSDoc comments on each function. Keep it simple — these are plain object factories, no classes.
  </action>
  <verify>
Run `node -e "const t = require('./tasks/types'); console.log(Object.keys(t))"` from workspace root — should print the 3 exported function names.

Run `node -e "const t = require('./tasks/types'); console.log(JSON.stringify(t.createTaskRequest('calendar', 'get', {date: 'today'}), null, 2))"` — should print a valid NormalizedTaskRequest.

Run `node -e "const t = require('./tasks/types'); try { t.createTaskRequest() } catch(e) { console.log('OK:', e.message) }"` — should print validation error.
  </verify>
  <done>types.js exports createTaskRequest, createLLMPayload, and createErrorPayload. Factory functions produce correctly shaped objects. Missing required fields throw clear errors.</done>
</task>

<task type="auto">
  <name>Task 2: Create read-msg.js request normalizer</name>
  <files>tasks/read-msg.js</files>
  <action>
Create `tasks/read-msg.js` at workspace root.

This module normalizes raw upstream requests into NormalizedTaskRequest objects (INFRA-01).

The agent platform (OpenClaw) sends requests as either:
1. A string like "calendar get today" or "weather today"
2. An object like `{ task: 'calendar', intent: 'get', parameters: { date: 'today' } }`

Export one function: `normalizeRequest(input)`

**If input is an object:** Validate it has `task` (string) and `intent` (string). Extract `parameters` (default {}). Use `createTaskRequest()` from types.js. Preserve original input as `raw` (JSON.stringify the object).

**If input is a string:** Parse it as space-separated tokens. First token = task, second token = intent, remaining tokens = join as a single `query` parameter. Example: `"calendar get today"` becomes `{ task: 'calendar', intent: 'get', parameters: { query: 'today' } }`. If only one token (just task name), default intent to 'get'. If empty string, throw error.

**Validation rules:**
- `task` must be a non-empty string
- `intent` must be a non-empty string
- `parameters` must be an object (not array, not null)
- On validation failure, throw an Error with a descriptive message

Follow project conventions: CommonJS, 2-space indent, JSDoc. Import createTaskRequest from ./types.
  </action>
  <verify>
Run `node -e "const r = require('./tasks/read-msg'); console.log(JSON.stringify(r.normalizeRequest('calendar get today'), null, 2))"` — should print normalized request with task=calendar, intent=get, parameters.query=today.

Run `node -e "const r = require('./tasks/read-msg'); console.log(JSON.stringify(r.normalizeRequest({task: 'weather', intent: 'get', parameters: {location: 'Portland'}}), null, 2))"` — should print normalized request.

Run `node -e "const r = require('./tasks/read-msg'); try { r.normalizeRequest('') } catch(e) { console.log('OK:', e.message) }"` — should print validation error.

Run `node -e "const r = require('./tasks/read-msg'); try { r.normalizeRequest({task: 'x'}) } catch(e) { console.log('OK:', e.message) }"` — should print error about missing intent.
  </verify>
  <done>read-msg.js normalizes both string and object inputs into NormalizedTaskRequest objects. Invalid inputs throw descriptive errors. Both string parsing and object validation paths work correctly.</done>
</task>

</tasks>

<verification>
1. `node -e "require('./tasks/types')"` succeeds without error
2. `node -e "require('./tasks/read-msg')"` succeeds without error
3. String input normalization: `"calendar get today"` -> NormalizedTaskRequest
4. Object input normalization: `{task, intent, parameters}` -> NormalizedTaskRequest
5. Validation errors on missing/invalid fields
6. LLMPayload factory produces correct shape with defaults
7. Error payload factory produces correct shape with error message
</verification>

<success_criteria>
- types.js defines and exports the two core data shapes (NormalizedTaskRequest, LLMPayload) as factory functions
- read-msg.js normalizes string and object inputs into NormalizedTaskRequest
- Both modules load without errors and all verify commands pass
- No external dependencies added (pure Node.js)
</success_criteria>

<output>
After completion, create `.planning/phases/07-task-infrastructure/07-01-SUMMARY.md`
</output>
