---
phase: 02-add-the-ability-for-the-bot-to-create-a-telegram-poll
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - tasks/poll/helpers/process-vote.js
  - tasks/poll/helpers/check-timeout.js
  - tasks/poll/config.js
autonomous: true

must_haves:
  truths:
    - "When both users have voted and there is a tie, the bot casts a tie-breaking vote with AI reasoning and announces it"
    - "When both users have voted and there is no tie, the bot stays silent and closes the poll"
    - "If a poll times out before both users vote, the bot picks the leading option or decides if no votes"
    - "Bot records each user's vote in poll state when a poll_answer update is received"
  artifacts:
    - path: "tasks/poll/helpers/process-vote.js"
      provides: "Vote recording, tie detection, tie-break decision, poll resolution"
      contains: "processVote"
    - path: "tasks/poll/helpers/check-timeout.js"
      provides: "Timeout check for heartbeat integration"
      contains: "checkPollTimeout"
    - path: "tasks/poll/config.js"
      provides: "Updated config with vote and check-timeout intents"
      contains: "vote"
  key_links:
    - from: "tasks/poll/helpers/process-vote.js"
      to: "tasks/poll/helpers/poll-state.js"
      via: "reads and updates poll state with vote data"
      pattern: "require.*poll-state"
    - from: "tasks/poll/helpers/process-vote.js"
      to: "tasks/poll/helpers/telegram-api.js"
      via: "calls stopPoll and sendMessage for tie-break announcement"
      pattern: "require.*telegram-api"
    - from: "tasks/poll/helpers/check-timeout.js"
      to: "tasks/poll/helpers/poll-state.js"
      via: "reads poll state to check creation time vs timeout"
      pattern: "require.*poll-state"
    - from: "tasks/poll/config.js"
      to: "tasks/poll/helpers/process-vote.js"
      via: "helpers map references processVote"
      pattern: "helpers.*processVote"
---

<objective>
Implement vote processing, tie-break logic, and timeout handling for the poll task module.

Purpose: Complete the poll lifecycle â€” from receiving votes to resolving the poll (tie-break announcement or silent close). This makes polls functional end-to-end: create -> vote -> resolve.

Output: Working `vote` and `check-timeout` intents on the poll task that the agent can call when receiving poll_answer updates and during heartbeat polls.
</objective>

<execution_context>
@/Users/greg/.claude/get-shit-done/workflows/execute-plan.md
@/Users/greg/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-add-the-ability-for-the-bot-to-create-a-telegram-poll/02-01-SUMMARY.md

@tasks/orchestrator.js
@tasks/types.js
@tasks/poll/config.js
@tasks/poll/helpers/telegram-api.js
@tasks/poll/helpers/poll-state.js
@household/meals/this-week.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create vote processing helper with tie detection and AI tie-break</name>
  <files>
    tasks/poll/helpers/process-vote.js
  </files>
  <action>
Create `tasks/poll/helpers/process-vote.js` â€” handles incoming poll_answer updates.

**`processVote(parameters, context)` function:**

Parameters expected:
- `parameters.userId` â€” Telegram user ID (string) of the voter
- `parameters.optionId` â€” 0-based index of the selected option (number/string)

**Logic:**

1. Load poll state. If no active poll, throw "No active poll found."
2. Load credentials to get `telegram_user_ids` (the two household members).
3. Record the vote: `state.activePoll.votes[userId] = parseInt(optionId)`
4. Save updated state.
5. Get the expected voter IDs from `telegram_user_ids` object values (convert to strings).
6. Check if all expected voters have voted: every expected user ID has a key in `votes`.
7. If not all voted yet, return `{ recorded: true, waitingFor: remainingUserNames }` (map IDs back to names for friendly output).
8. If all voted, determine the result:

**Result determination:**
- Count votes per option index. Build a frequency map: `{ 0: 1, 1: 1 }` (tie) or `{ 0: 2 }` (agreement).
- Find the max vote count. If multiple options share the max count, it's a tie.

**If NO tie (both agreed):**
- Call `stopPoll(botToken, chatId, messageId)` to close the poll.
- Call `clearActivePoll()`.
- Return `{ resolved: true, winner: winningOptionText, tie: false, silent: true }`.
- Per user decision: bot stays silent when both agreed. Do NOT send a message.

**If TIE:**
- The bot must cast a tie-breaking vote using AI reasoning with household context.
- Build a tie-break context object:
  ```javascript
  const tieBreakContext = {
    question: state.activePoll.question,
    tiedOptions: tiedOptionTexts, // array of option texts that are tied
    // Read household context for reasoning
    mealPlan: null,  // will be populated below
    recentNotes: null
  };
  ```
- Read `household/meals/this-week.md` (try/catch, null if missing) â€” provides recent meal context for dinner polls.
- Read `household/notes.md` last 10 lines (try/catch, null if missing) â€” provides recent activity context.
- Attach to tieBreakContext.
- **Choose the tie-break winner:** Since the bot can't call an LLM from within a task helper (no LLM API access from Node.js), use a simple heuristic-based approach:
  - For meal-related polls (question contains "dinner", "eat", "food", "meal", "lunch"): check this-week.md for recent meals. Pick the option that does NOT appear in recent meals (avoid repetition). If can't determine, pick randomly.
  - For other polls: pick randomly from tied options.
  - Store the reasoning string explaining why.
- Call `stopPoll(botToken, chatId, messageId)` to close the poll.
- Build announcement message: `"Tie! ðŸ¤– I'm going with {winner} â€” {reasoning}"` (e.g., "Tie! ðŸ¤– I'm going with tacos â€” you had pizza twice this week already!")
- Call `sendMessage(botToken, chatId, announcement)`.
- Call `clearActivePoll()`.
- Return `{ resolved: true, winner: winnerText, tie: true, reasoning: reasoningText, announcement: announcementText }`.

**Meal repetition check helper (internal function `avoidRepeatMeal`):**
- Parse this-week.md to extract meal descriptions for each day.
- Check if any tied option (case-insensitive) appears in recent meal entries.
- Prefer the option that appears LEAST in recent meals.
- If all appear equally (0 or same count), pick randomly.
- Reasoning examples: "you had pizza twice this week already!", "sushi hasn't been on the menu recently", "random pick since both are new this week"
  </action>
  <verify>
Run `node -e "const p = require('./tasks/poll/helpers/process-vote'); console.log(typeof p.processVote)"` â€” should print `function`.

Create a temporary test: manually write a poll-state.json with an active poll, then call processVote with mock parameters to verify the logic path (will fail at Telegram API call but should get through vote recording and tie detection).
  </verify>
  <done>
processVote helper records votes, detects when all household members have voted, identifies ties, performs heuristic-based tie-breaking with household context (meal plan awareness), sends announcement via Telegram, and closes the poll. Returns structured result indicating resolution status.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create timeout checker and update poll config with new intents</name>
  <files>
    tasks/poll/helpers/check-timeout.js
    tasks/poll/config.js
  </files>
  <action>
Create `tasks/poll/helpers/check-timeout.js` â€” called during heartbeat to check for timed-out polls.

**`checkPollTimeout(parameters, context)` function:**

1. Load poll state. If no active poll, return `{ hasActivePoll: false }`.
2. Load credentials.
3. Calculate elapsed time: `Date.now() - new Date(state.activePoll.createdAt).getTime()`.
4. Calculate timeout in ms: `state.activePoll.timeoutMinutes * 60 * 1000`.
5. If elapsed < timeout, return `{ hasActivePoll: true, timedOut: false, minutesRemaining: Math.ceil((timeout - elapsed) / 60000) }`.
6. If elapsed >= timeout (poll has timed out):

**Timeout resolution:**
- Count votes per option from `state.activePoll.votes`.
- If votes exist and there's a clear leader (one option has more votes): pick that option as winner. Reasoning: "Poll timed out â€” going with {winner} since it was in the lead!"
- If votes exist but tied: use the same `avoidRepeatMeal` heuristic from process-vote.js if meal-related, else random. Reasoning: "Poll timed out with a tie â€” I'm picking {winner}!"
- If no votes at all: pick randomly. Reasoning: "Nobody voted, so I'm deciding â€” {winner} it is!"
- Call `stopPoll(botToken, chatId, messageId)`.
- Build and send announcement: `"â° Poll timed out! {reasoning}"`.
- Call `sendMessage(botToken, chatId, announcement)`.
- Call `clearActivePoll()`.
- Return `{ hasActivePoll: true, timedOut: true, winner: winnerText, reasoning }`.

**Shared meal heuristic:** To avoid duplicating the meal repetition logic, extract it. Create a small internal helper function `pickFromTiedOptions(tiedOptions, question)` that both process-vote.js and check-timeout.js can use. Place this in a new file `tasks/poll/helpers/tie-break.js` that both files can require. This helper:
- Takes `tiedOptions` (array of strings) and `question` (string)
- If question is meal-related (contains dinner/eat/food/meal/lunch): reads this-week.md and picks the least-repeated option
- Otherwise: picks randomly
- Returns `{ winner: string, reasoning: string }`

Update `tasks/poll/config.js` to add the two new intents:

```javascript
'vote': {
  helpers: ['processVote'],
  validate: (params) => {
    if (!params.userId) return 'userId is required';
    if (params.optionId === undefined || params.optionId === null) return 'optionId is required';
    return null;
  }
},
'check-timeout': {
  helpers: ['checkTimeout']
}
```

Add the new helpers to the helpers map:
```javascript
'processVote': processVoteHelper,
'checkTimeout': checkTimeoutHelper
```

Add the requires at the top of config.js for the new helpers.
  </action>
  <verify>
Run `node -e "const c = require('./tasks/poll/config'); console.log(Object.keys(c.intents).sort().join(','))"` â€” should print `check-timeout,create,stop,vote`.

Run `node tasks/index.js "poll check-timeout"` â€” should return a payload with `hasActivePoll: false` (no active poll). This verifies the full pipeline works end-to-end.

Run `node tasks/index.js "poll vote userId=123 optionId=0"` â€” should return an error about no active poll (expected). Confirms validation passes and helper executes.

Run `node -e "const tb = require('./tasks/poll/helpers/tie-break'); console.log(typeof tb.pickFromTiedOptions)"` â€” should print `function`.
  </verify>
  <done>
Poll task has 4 intents: create, stop, vote, check-timeout. Vote processing detects ties and resolves with household-context-aware heuristics. Timeout checker can be called from heartbeat to auto-resolve stale polls. Tie-break logic is shared between vote and timeout handlers. The full poll lifecycle is complete: create -> vote -> resolve (or timeout).
  </done>
</task>

</tasks>

<verification>
1. `node tasks/index.js "poll check-timeout"` returns `{ hasActivePoll: false }` payload (no errors)
2. `node tasks/index.js "poll vote userId=123 optionId=0"` returns error payload "No active poll found." (correct behavior)
3. `node tasks/index.js "poll create question=Test options=A,B"` fails with credentials error (expected, confirms full pipeline)
4. `tasks/poll/helpers/tie-break.js` exists and exports `pickFromTiedOptions`
5. All helpers use only built-in Node.js modules (https, fs, path)
</verification>

<success_criteria>
The poll task module supports the complete poll lifecycle: creating polls, recording votes, detecting ties, performing AI-heuristic tie-breaking with household context (meal repetition avoidance), timeout handling, and automatic poll closure with announcements. All 4 intents (create, stop, vote, check-timeout) are functional and return structured LLMPayload responses.
</success_criteria>

<output>
After completion, create `.planning/phases/02-add-the-ability-for-the-bot-to-create-a-telegram-poll/02-02-SUMMARY.md`
</output>
